
import { supabase } from "@/integrations/supabase/client";

export interface FurnitureTransaction {
  id: string;
  tracking_number: string;
  student_id: string;
  transaction_type: 'distribution' | 'return';
  chair_quantity: number;
  locker_quantity: number;
  transaction_date: string;
  condition?: string;
  compensation_fee?: number;
  notes?: string;
  created_at: string;
  updated_at: string;
}

export interface CreateFurnitureTransaction {
  student_id: string;
  transaction_type: 'distribution' | 'return';
  chair_quantity?: number;
  locker_quantity?: number;
  condition?: 'good' | 'bad' | 'new';
  compensation_fee?: number;
  notes?: string;
}

export interface FurnitureStock {
  id: string;
  item_type: 'chair' | 'locker';
  available_quantity: number;
  total_quantity: number;
  created_at: string;
  updated_at: string;
}

export const getFurnitureStock = async (): Promise<FurnitureStock[]> => {
  const { data, error } = await supabase
    .from('furniture_stock')
    .select('*')
    .order('item_type');

  if (error) {
    console.error('Error fetching furniture stock:', error);
    throw new Error('Failed to fetch furniture stock');
  }

  return (data || []) as FurnitureStock[];
};

export const updateFurnitureStock = async (
  itemType: 'chair' | 'locker', 
  availableQuantity: number, 
  totalQuantity: number
): Promise<void> => {
  const { error } = await supabase
    .from('furniture_stock')
    .update({ 
      available_quantity: availableQuantity,
      total_quantity: totalQuantity
    })
    .eq('item_type', itemType);

  if (error) {
    console.error('Error updating furniture stock:', error);
    throw new Error('Failed to update furniture stock');
  }
};

export const createFurnitureTransaction = async (transaction: CreateFurnitureTransaction): Promise<FurnitureTransaction> => {
  const { data, error } = await supabase
    .from('furniture_transactions')
    .insert({
      student_id: transaction.student_id,
      transaction_type: transaction.transaction_type,
      chair_quantity: transaction.chair_quantity || 0,
      locker_quantity: transaction.locker_quantity || 0,
      condition: transaction.condition || 'new',
      compensation_fee: transaction.compensation_fee || 0,
      notes: transaction.notes,
      tracking_number: '' // Will be auto-generated by the database trigger
    })
    .select()
    .single();

  if (error) {
    console.error('Error creating furniture transaction:', error);
    throw new Error('Failed to create furniture transaction');
  }

  return data as FurnitureTransaction;
};

export const getFurnitureTransactions = async (): Promise<FurnitureTransaction[]> => {
  const { data, error } = await supabase
    .from('furniture_transactions')
    .select(`
      *,
      students (
        student_name,
        registration_number,
        grade
      )
    `)
    .order('created_at', { ascending: false });

  if (error) {
    console.error('Error fetching furniture transactions:', error);
    throw new Error('Failed to fetch furniture transactions');
  }

  return (data || []) as FurnitureTransaction[];
};

export const getFurnitureTransactionsByStudent = async (studentId: string): Promise<FurnitureTransaction[]> => {
  const { data, error } = await supabase
    .from('furniture_transactions')
    .select('*')
    .eq('student_id', studentId)
    .order('created_at', { ascending: false });

  if (error) {
    console.error('Error fetching student furniture transactions:', error);
    throw new Error('Failed to fetch student furniture transactions');
  }

  return (data || []) as FurnitureTransaction[];
};

export const getStudentFurnitureBalance = async (studentId: string) => {
  const transactions = await getFurnitureTransactionsByStudent(studentId);
  
  let chairBalance = 0;
  let lockerBalance = 0;

  transactions.forEach(transaction => {
    if (transaction.transaction_type === 'distribution') {
      chairBalance += transaction.chair_quantity;
      lockerBalance += transaction.locker_quantity;
    } else if (transaction.transaction_type === 'return') {
      chairBalance -= transaction.chair_quantity;
      lockerBalance -= transaction.locker_quantity;
    }
  });

  return {
    chairs: chairBalance,
    lockers: lockerBalance,
    transactions
  };
};

export const getStudentsWithFurniture = async (grade?: string) => {
  const { data, error } = await supabase
    .from('students')
    .select(`
      id,
      student_name,
      registration_number,
      grade,
      furniture_transactions (
        chair_quantity,
        locker_quantity,
        transaction_type
      )
    `)
    .eq(grade ? 'grade' : 'id', grade || 'id');

  if (error) {
    console.error('Error fetching students with furniture:', error);
    throw new Error('Failed to fetch students with furniture');
  }

  // Filter students who currently have furniture
  const studentsWithFurniture = data?.filter(student => {
    let chairBalance = 0;
    let lockerBalance = 0;

    student.furniture_transactions?.forEach((transaction: any) => {
      if (transaction.transaction_type === 'distribution') {
        chairBalance += transaction.chair_quantity || 0;
        lockerBalance += transaction.locker_quantity || 0;
      } else if (transaction.transaction_type === 'return') {
        chairBalance -= transaction.chair_quantity || 0;
        lockerBalance -= transaction.locker_quantity || 0;
      }
    });

    return chairBalance > 0 || lockerBalance > 0;
  }) || [];

  return studentsWithFurniture;
};
